#include <iostream>
using namespace std;
template<typename Key, typename Info>
class Ring{
private:
    struct Node{
        Key key;
        Info info;
        Node* next;
        Node* prev;
    };
    Node* start;
    int version;
    int size;
public:
    class Iterator{
    private:
        friend Ring<Key, Info>;
        Node* p=nullptr;
        Iterator(Node* nodePtr){ p = nodePtr;}
        const Ring<Key, Info>* owner;
        int expectedVersion;
    public:
    ~Iterator(){};
        Iterator& operator++()
        {
            if(!empty())
            {
                p = p->next;
            }
            return *this;
        }
        Iterator operator++(int)
        {
            Iterator temp = *this;
            (*this)++;
            return temp;
        }
        Iterator& operator--()
        {
            if(!empty())
            {
                p = p->prev;
            }
            return *this;
        }
        Iterator operator--(int)
        {
            Iterator temp = *this;
            --(*this);
            return temp;
        }
        bool operator==(const Iterator& toCompare) const
        {
            return p == toCompare.p;
        }
        bool operator!=(const Iterator& toCompare) const
        {
            return p != toCompare.p;
        }
        class NoPointer{};
        Info& operator*() const
        {
            if(empty())
            {
                throw NoPointer();
            }
            return p->info;
        }
        bool getAll(Key& keyToReturn, Info& infoToReturn)
        {
            if(empty())
            {
                return false;
            }
            keyToReturn = p->key;
            infoToReturn = p->info;
            return true;
        }
        bool empty() const {return p==nullptr;}
        int getVersion(){return expectedVersion;}
    };
    Ring():start(nullptr), size(0), version(0){}
    Ring(const Ring<Key, Info>& toCopy)
    {
        start = nullptr;
        size = toCopy.size;
        version = toCopy.version;
        Iterator itr = toCopy.begin();
        if(itr.empty())
        {
            return;
        }
        do{
            insertEnd(itr.p->key, itr.p->info);
            itr++;
        }while(itr.p != toCopy.start);
    }
    ~Ring()
    {
        clearContents();
    }
    Ring<Key, Info>& operator=(const Ring<Key, Info>& toCopy)
    {
        if(this == &toCopy)
        {
            return *this;
        }
        clearContents();
        Iterator itr = toCopy.begin();
        version = toCopy.version;
        size = toCopy.size;
        if(itr.empty() == false)
        {
            do{
            insertEnd(itr.p->key, itr.p->info);
            itr++;
            }while(itr.p != toCopy.start);
        }
        return *this;
    }
    void insertEnd(const Key& what, const Info& iwhat)
    {
        Node* newNode = new Node;
        newNode->key = what;
        newNode->info = iwhat;
        if(start==nullptr)
        {
            newNode->next = newNode;
            newNode->prev = newNode;
            start = newNode;
        }
        else
        {
            newNode->next = start;
            newNode->prev = start->prev;
            start->prev->next = newNode;
            start->prev = newNode;
        }
        size++;
    }
    bool insertAfter(const Key& what, const Info& iwhat, Iterator itr)
    {
        if(isIteratorValid(itr) == false)
        {
            return false;
        }
        Node* newNode = new Node;
        newNode->key = what;
        newNode->info = iwhat;
        newNode->next = itr.p->next;
        newNode->prev = itr.p;
        itr.p->next->prev = newNode;
        itr.p->next = newNode;
        size++;
        return true;
    }
    bool remove(Iterator& itr)
    {
        if(isIteratorValid(itr) == false)
        {
            return false;
        }
        if(itr.p == start)
        {
            start = start->next;
        }
        itr.p->next->prev = itr.p->prev;
        itr.p->prev->next = itr.p->next;
        Node* itrNode = itr.p;
        if(itr.p == itr.p->next) 
        {
            itr.p = nullptr;
            start = nullptr;
        }
        itr++;
        delete itrNode;
        version++;
        itr.expectedVersion++;
        size--;
        return true;
    }
    Iterator search(const Key& keyToFind, int which)
    {
        Iterator itr = begin();
        if(which == 0 || size == 0)
        {
            itr.p = nullptr;
            return itr;
        }
        int checked = size;
        while(checked > 0)
        {
            if (itr.p->key == keyToFind)
            {
                if(which > 0)
                    which--;
                else which++;
                if(which == 0)
                    break;
            } 
            checked--;
            if(which > 0)
                itr++;
            else itr--;
        }
        if(which != 0)
        {
            itr.p = nullptr;
        }
        return itr;
    }
    bool getInfo(Iterator itr, Info& infoToReturn)
    {
        if(isIteratorValid(itr) == false)
        {
            return false;
        }
        infoToReturn = itr.p->info;
        return true;
    }
    int getSize(){return size;}
    int getVersion(){return version;}
    void clearContents()
    {
        Iterator itr = begin();
        while(size>0)
        {
            Node* itrNode = itr.p;
            itr++;
            size--;
            delete itrNode;
        }
        start = nullptr;
        version++;
    }
    Iterator begin() const{
        Iterator toReturn = Iterator(start);
        toReturn.owner = this;
        toReturn.expectedVersion = version;
        return toReturn;
    }
    bool isIteratorValid(Iterator itr)
    {
        if(itr.empty() || itr.owner != this || version != itr.expectedVersion)
        {
            return false;
        }
        return true;
    }
    void print()
    {
        Iterator itr = begin();
        if(itr.empty())
        {
            return;
        }
        do{
            cout << itr.p->key << " " << itr.p->info << endl;
            itr++;
        }while(itr.p != start);
    }
    friend ostream& operator<<(ostream& os, const Ring<Key, Info>& ringToPrint)
    {
        Iterator itr = ringToPrint.begin();
        int elementsLeft = ringToPrint.size;
        if(itr.empty() == false)
        {
            while(elementsLeft > 0)
            {
                Info itrInfo;
                Key itrKey;
                itr.getAll(itrKey, itrInfo);
                os << itrKey << " " << itrInfo << endl;
                itr++;
                elementsLeft--;
            }
        }
        return os;
    }
};
//function outside of class - no access to private data of the class
template<typename Key, typename Info>
Ring<Key, Info> produce(const Ring<Key, Info>& source1, int step1, bool direction1,
                        const Ring<Key, Info>& source2, int step2, bool direction2, int length)
{
    Ring<Key, Info> toReturn;
    if(step1<0 || step2<0 || length <= 0)
    {
        return toReturn;
    }
    typename Ring<Key, Info>::Iterator itr1 = source1.begin();
    typename Ring<Key, Info>::Iterator itr2 = source2.begin();
    Key keyToCopy;
    Info infoToCopy;
    while(length > 0)
    {
        for(int i = 0; i < step1; i++)
        {
            if(length == 0)
                break;
            itr1.getAll(keyToCopy, infoToCopy);
            toReturn.insertEnd(keyToCopy, infoToCopy);
            if(direction1 == true)
                itr1++;
            else itr1--;
            length--;
        }
        for(int i = 0; i < step2; i++)
        {
            if(length == 0)
                break;
            itr2.getAll(keyToCopy, infoToCopy);
            toReturn.insertEnd(keyToCopy, infoToCopy);
            if(direction2 == true)
                itr2++;
            else itr2--;
            length--;
        }
    }
    return toReturn;
}
/* direction: 1 - clockwise, 0 counterclockwise;
    length: total length - if exceeded it stops
    step: how much to take per cycle
    copying elements from sources
    remember to connect last with first
    goes forever if length is not exceeded
    if one of them is empty we just ignore it
*/
